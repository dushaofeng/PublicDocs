class A{
    int name=3;
    int area(){
        System.out.println("A");
        return 1;
    }
}
class C extends A{
    int name=4;
    int  area(){
        System.out.println("C类方法");
        return 1;}
    public static void main(String[]args){
        A a = new C();
        a.area();
        System.out.println(a.name);
    }
}

输出结果为
c类方法
3

我不明白，实际上创建的是子类的实例，为什么调用的是子类的方法，父类的成员变量？
如果说，因为子类重写了父类的方法，那还可以理解，可是为什么成员变量name会是父类的值3？而不是子类的值4？
那么我就C c=new C();  
System.out.println(c.name);     输出的是竟然是4  
C c ，A a，只是一个存放地址的指针。实际的对象都是 子类C啊，那么name的值都应该是4不是吗？为什么会出现不同的结果？

还有，当我把A类的area()方法删除，也就是只有子类有area()这个方法，重新编译，结果出现了错误，根本访问不到area()这个方法。实际创建的对象是子类，子类当然可以访问area这个方法，怎么会出现了错误呢？ 网上搜搜说必须强制转换成子类才可以访问子类的方法，我不清楚怎么回事。

子类和父类的转换，我不明白这究竟有什么转换啊，还是 A a有什么其他的意思？

我还不清楚 父类强制转换成子类 怎么转，这个教程好像网上的也少，希望大家帮帮啊！

万分感谢！

答：
这是java多态性的表现，要深入理解的话得从内存方面去思考，创建的是子类对象，但是指针类型是父类的，它能指向的内存块是父类应能对应的内容。当你把A类得Area()方法删除时，a指向的内存块里没有Area方法，或者说它指向的这个对象虽然有这个方法，但是这个指针却是没法去访问该方法的， 所以出现无法访问的情况。
然后是a.name=3这个问题，这是由于直接访问成员变量的话 指针指向的任然是父类成员变量，这点记住就行，实际中一般都设getName()、setName()方法进行访问和设置，把name设为private，这样才符合面向对象封装特性，你可以试一下，a.getName()的结果肯定是4
另外父类转化为子类的问题，父类转化为子类不是一定可行的，父类要想转化为子类，其指向的内存块的内容一定要大于等于子类，（即指向对象一定要是子类或者子类的子类。。。）
比如：
A a = new C();
此时把a强制转换为子类是正确的
而A a = new A();
此时把a强制转换为子类则会出错
希望对你有帮助，有不明白的地方可以再问我


首先A a = new C();这条语句利用了java中的多态特性，即子类对象可以当做父类对象来看。
但是，若我们把子类对象当做父类对象来看是，那么就只能访问父类已有定义的属性和方法，不能访问子类扩展的属性和方法。要是子类把父类的方法覆盖了，再把子类对象的当做父类对象来看，去调用方法，调用的是覆盖后的方法（子类中定义的方法）。
还有就是关于name=3的问题。要记住java中只有在普通的方法中才能表现出多态特性，变量是没有多态存在的，所以是不会输出name = 4.
至于类的转换:
引用类型转换（是引用变量的类型的转换！）
 1 向下转型（自动类型转换），是小类型到大类型的转换
    如：
    Circle c = new Circle(1,2,3);
    Shape s = c;//表示圆一定是图形
    2 向上造型（强制类型转换），是大类型到小类型。
    如：
    Shape s = new Circle(1,2,3);
    Cirlcle c = (Circle)s; //当s实际引用圆时候，能够转换成功
    s = new Rectangle(1,1,2,2);
    Circle c2 = (Circle) s;//出现类型转换异常，因为
    // s引用的是Rectangle 不是圆实例。
    3 instanceof 运算符，用来检查引用对象的类型。
    经常与“引用类型强制转换”配合，实现安全的类型换，
    避免类型转换异常。
    如你例子中的就是向下转型，也就是多态，若果要父类转成子类，就是向上转型，这要 承担出异常的后果，所以转换前要用instanceof判断该父类是否是子类的实例才可。
